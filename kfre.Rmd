---
title: "Heterogeneous treatment effects of intensive glycemic control on kidney microvascular outcomes in ACCORD"
author: "Vivek Charu, Jane W. Liang, Glenn M. Chertow, June Li, Maria E. Montez-Rath, Pascal Geldsetzer, Ian de Boer, Lu Tian, and Manjula Kurella Tamura"
output: html_document
date: "2023-05-02"
---

```{r setup, results = 'hide', message = FALSE, warning = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
library(tidyverse)
library(survminer)

library(survival)
library(survRM2)

library(foreach)
library(doParallel)

# Cluster object
cl = parallel::makeCluster(parallel::detectCores() - 2)
# Register parallel backend
registerDoParallel(cl)

# Set background to be white for all ggplots
theme_set(theme_classic())
```

## Data processing

We read in the data and extract the outcome and covariate variables of interest. Duplicate observations and observations where the treatment arm or variables needed to calculate the KFRE are missing are dropped. 

```{r}
# Read in datasets
raw_data = read.csv("/Users/jliang/Library/CloudStorage/Box-Box/Jane-Vivek/ACCORD HTE Analysis/Data/New data 26SEP2022/accordall.csv", header = TRUE)
other_df = read.csv("/Users/jliang/Library/CloudStorage/Box-Box/Jane-Vivek/ACCORD HTE Analysis/Data/ACCORD_GLY_NEWOUTCOMES-2.csv", header = TRUE)

# Subset for death outcomes
other_df = other_df %>%
  select(maskid = id, ALLDEATH, alldeath_fu, CVDEATH, cvdeath_fu)

# Merge in death outcome
raw_data = merge(raw_data, other_df, by = "maskid", all.x = TRUE)

# Create composite kidney outcome
raw_data$neph_composite = pmax(raw_data$Neph2, raw_data$Neph3)
raw_data$neph_composite_fu = pmin(raw_data$Neph2Days, raw_data$Neph3Days)

# Quantitative variables to potentially include in the models 
subset_quant = c("female", "baseline_age", "raceth", 
                 "sbp", "dbp", "pulsepres",
                 "chol", "trig", "vldl", "ldl", "hdl",
                 "alt", "cpk",
                 "fpg", "hba1c", 
                 "ualb", "ucreat", "uacr", 
                 "ckd2021GFR", "screat", 
                 "bmi", 
                 "smokelif") # Add smoking to calculate DKD score)

# List of outcome variables 
outcome_list = list(
  neph_composite = c(status = "neph_composite", time = "neph_composite_fu"), 
  Neph2 = c(status = "Neph2", time = "Neph2Days"), 
  Neph3 = c(status = "Neph3", time = "Neph3Days"), 
  ALLDEATH = c(status = "ALLDEATH", time = "alldeath_fu"), 
  CVDEATH = c(status = "CVDEATH", time = "cvdeath_fu"))
# All outcomes
outcomes = unlist(outcome_list, use.names = FALSE)

# Race should be a factor
raw_data$raceth = as.factor(raw_data$raceth)

# Make relevant exclusions and define new dataset 
df = raw_data %>% 
  select(all_of(c("maskid", "glyarm", "kfrs", outcomes, subset_quant))) %>%
  drop_na(all_of(c("glyarm", "kfrs"))) %>% # Drop those with missing values
  unique() # Drop duplicates

# Include race contrasts
df = data.frame(df, 
                raceth0 = ifelse(df$raceth == 0, 1, 0), 
                model.matrix(~raceth, df)[,-1])
```

We define a data frame that standardizes all continuous variables to have mean 0 and standard deviation 1. 

```{r}
# All covariates considered + race split into contrasts
expanded_covariates = c(setdiff(subset_quant, "raceth"), 
                        paste0("raceth", 0:3))
# Binary variables
binary_vars = apply(df[,expanded_covariates], 2, function(x){
  length(unique(x)) == 2 && all(sort(unique(x)) == c(0, 1))
})

# Data where continuous covariates are standardized
# Binary variables are left alone
std_df = sapply(1:length(expanded_covariates), function(i) {
  if (binary_vars[i] == FALSE) {
    return(scale(df[,expanded_covariates][,i]))
  } else {
    return(df[,expanded_covariates][,i])
  }
})
colnames(std_df) = expanded_covariates
```

## Kidney failure risk equation (KFRE)

We calculate the 5-year predicted risk using the KFRE, define KFRE quartiles, and plot the distributions within treatment arms. 

```{r}
# Calculate 5-year KFRE
df$kfre5 = with(df, {
  1 - 0.8996^exp(-0.2201 * (baseline_age/10 - 7.036) + 
                   0.2467 * ((female==0) - 0.5642) - 
                   0.5567 * (ckd2021GFR/5 - 7.222) + 
                   0.4510 * ( log(uacr) - 5.137))
})

# kfre quartile thresholds
kfre_quart_thresh = quantile(df$kfre5, seq(0.25, 0.75, by = 0.25))
# Create groups based on thresholds
df$kfre_quarts = as.numeric(cut(df$kfre5, 
                                breaks = c(-Inf, as.numeric(kfre_quart_thresh), Inf),
                                labels = c(1:(length(kfre_quart_thresh)+1))))

# Histograms of KFRE for treatment and control
df %>% 
  ggplot(aes(x = kfre5, fill = as.factor(glyarm), color = as.factor(glyarm))) + 
  geom_histogram(alpha = 0.3, position="identity") + 
  scale_x_log10() + 
  geom_vline(xintercept = kfre_quart_thresh, color = "gray60") + 
  xlab("5-year predicted risk by KFRE (log)") + ylab("") + 
  scale_fill_discrete(name = "", labels = c("0" = "Control", "1" = "Treatment")) + 
  scale_color_discrete(name = "", labels = c("0" = "Control", "1" = "Treatment"))
ggsave("figs_and_tabs/kfre_hist.png", width = 6, height = 4)

# Distribution of KFRE for treatment and control
kfre_dist_tab = data.frame(
  do.call(rbind, c(list(summary(df$kfre5)), 
                 tapply(df$kfre5, df$glyarm, summary))), 
  row.names = c("Overall", "Control", "Treatment")
)
names(kfre_dist_tab) = c("Min", "Q1", "Median", "Mean", "Q3", "Max")
write.csv(kfre_dist_tab %>% round(5), file = "figs_and_tabs/kfre_dist_tab.csv")
kfre_dist_tab %>% round(5)
```

These are summary statistics for the scores within each KFRE quartile. 

```{r}
# General summary function that returns the mean, standard deviation, median 
# and IQR of x
my_summary = function(x, na.rm = TRUE) {
  c("Mean" = mean(x, na.rm = na.rm), 
    "SD" = sd(x, na.rm = na.rm), 
    "Median" = median(x, na.rm = na.rm), 
    "IQR" = IQR(x, na.rm = na.rm))
}

# Summary stats for KFRE within quartile
kfre_quart_tab = data.frame(do.call(rbind, 
        lapply(1:4, function(i) {
          c(Quartile = i, 
            my_summary(df$kfre5[df$kfre_quarts==i]))
        })
))
write.csv(kfre_quart_tab %>% round(5), 
          file = "figs_and_tabs/kfre_quart_tab.csv", row.names = FALSE)
kfre_quart_tab %>% round(5)
```

Number of observations overall and in each arm. 

```{r}
c(table(raw_data$glyarm), Overall = nrow(raw_data))
```

Number of observations overall and in each arm, restricting to those with non-missing covariates needed to calculate KFRE. 

```{r}
c(table(df$glyarm), Overall = nrow(df))
```

Number of non-missing observations for each outcome. 

```{r}
t(sapply(outcome_list, function(x) {
  my_df = na.omit(df[,c(x["status"], x["time"], "glyarm")])
  c(table(my_df$glyarm), Overall = nrow(my_df))
}))
```

## Descriptive statistics

For each quartile and overall, we report the proportion (standard deviation) for all binary variables and the median (IQR) of all continuous variables in the dataset. 

```{r}
# Data dictionary for nice variable names
dat_dict = data.frame(rbind(
  c("female", "Female gender", "(yes/no)"), 
  c("raceth0", "White", "(yes/no)"), 
  c("raceth1", "Black", "(yes/no)"), 
  c("raceth3", "Hispanic", "(yes/no)"), 
  c("raceth2", "Other race/ethnicity", "(yes/no)"), 
  c("baseline_age", "Baseline age", "(years)"), 
  c("bmi", "Body mass index", "(kg/m2)"), 
  c("sbp", "Systolic blood pressure", "(mmHg)"), 
  c("dbp", "Diastolic blood pressure", "(mmHg)"), 
  c("pulsepres", "Pulse pressure", "(mmHg)"), 
  c("chol", "Total cholesterol", "(mg/dL)"), 
  c("trig", "Triglyercides", "(mg/dL)"), 
  c("vldl", "Very low density lipoprotein", "(mg/dL)"), 
  c("ldl", "Low density lipoprotein", "(mg/dL)"), 
  c("hdl", "High density lipoprotein", "(mg/dL)"), 
  c("alt", "Alanine aminotransferase", "(mg/dL)"), 
  c("cpk", "Creatine Phosphokinase", "(mg/dL)"), 
  c("fpg", "Fasting plasma glucose", "(mg/dL)"), 
  c("hba1c", "Glycosylated hemoglobin", "(%)"), 
  c("ualb", "Urinary albumin", "(mg/dL)"), 
  c("ucreat", "Urinary creatinine", "(mg/dL)"), 
  c("uacr", "Urinary albumin to creatinine ratio", "(mg/g)"), 
  c("ckd2021GFR", "Estimated glomerular filtration rate", "(mL/min/1.73m2)"), 
  c("screat", "Serum creatinine", "(mg/dL)"),  
  c("neph_composite", "Composite kidney outcome", "(yes/no)"), 
  c("Neph2", "Development of macro-albuminuria", "(yes/no)"), 
  c("Neph3", "Renal failure or ESRD (dialysis) or SCr>3.3", "(yes/no)"), 
  c("ALLDEATH", "All cause death", "(yes/no)"), 
  c("CVDEATH", "Cardiovascular death", "(yes/no)")
))
names(dat_dict) = c("short", "long", "units")

# Center (median or mean) of each variable
center_tab = cbind(
  # Overall
  sapply(c(expanded_covariates, names(outcome_list)), function(var) {
    if (var %in% c("glyarm", names(outcome_list), 
                   "female", paste0("raceth", 0:3))) { # Binary variables
      mean(df[,var], na.rm = TRUE)
    } else { # Continuous'
      median(df[,var], na.rm = TRUE)
    }
  }), 
  # By quartile
  sapply(1:4, function(i) {
    sapply(c(expanded_covariates, names(outcome_list)), function(var) {
      if (var %in% c("glyarm", names(outcome_list), 
                     "female", paste0("raceth", 0:3))) { # Binary variables
        mean(df[df$kfre_quarts==i,var], na.rm = TRUE)
      } else { # Continuous
        median(df[df$kfre_quarts==i,var], na.rm = TRUE)
      }
    })
  })
)

# Spread (IQR or standard deviation) of each variable
spread_tab = cbind(
  # Overall
  sapply(c(expanded_covariates, names(outcome_list)), function(var) {
    if (var %in% c("glyarm", names(outcome_list), 
                   "female", paste0("raceth", 0:3))) { # Binary variables
      sd(df[,var], na.rm = TRUE)
    } else { # Continuous
      IQR(df[,var], na.rm = TRUE)
    }
  }), 
  # By quartile
  sapply(1:4, function(i){
    sapply(c(expanded_covariates, names(outcome_list)), function(var) {
      if (var %in% c("glyarm", names(outcome_list), 
                     "female", paste0("raceth", 0:3))) { # Binary variables
        sd(df[df$kfre_quarts==i,var], na.rm = TRUE)
      } else { # Continuous
        IQR(df[df$kfre_quarts==i,var], na.rm = TRUE)
      }
    })
  })
)

# Number of non-missing values for each covariate
N_tab = sapply(c(expanded_covariates, names(outcome_list)), function(var) {
  sum(!is.na(df[,var]))
})

# Create Table 1
tab1 = matrix(paste0(round(center_tab, 2), " (", round(spread_tab, 2), ")"), 
              nrow = nrow(center_tab), ncol = 5)
rownames(tab1) = rownames(center_tab)
colnames(tab1) = c("Overall", paste("Quartile", 1:4))
tab1 = cbind(tab1, N = N_tab)

# Use more descriptive variable names
tab1 = merge(dat_dict, tab1, by.x = "short", by.y = 0, sort = FALSE)
rownames(tab1) = paste(tab1$long, tab1$units)
tab1$short = NULL; tab1$long = NULL; tab1$units = NULL
write.csv(tab1, file = "figs_and_tabs/tab1.csv")
tab1
```

## Balance between treatment and control arm within quartile

To check the balance between the treatment and control groups, we take the difference in standardized means for each covariate, within each treatment arm and quartile. 

```{r}
# Mean of each covariate across individuals within each quartile and treatment 
# group, for kfirs
# Standardized means were used for continuous covariates
std_means_balance_kfre = lapply(expanded_covariates, function(var) {
  tapply(std_df[,var], list(df$kfre_quarts, df$glyarm), 
         mean, na.rm = TRUE)
})
names(std_means_balance_kfre) = expanded_covariates

# Split into treatment and control
# Treatment
std_means_trt_kfre = sapply(expanded_covariates, function(var){
  std_means_balance_kfre[[var]][,"1"]
}) %>% t()

# Control
std_means_control_kfre = sapply(expanded_covariates, function(var){
  std_means_balance_kfre[[var]][,"0"]
}) %>% t()

# Difference between treatment and control
std_means_diff_kfre = 
  merge(dat_dict, 
        sapply(expanded_covariates, function(var){
          std_means_balance_kfre[[var]][,"1"] - 
            std_means_balance_kfre[[var]][,"0"]
          }) %>% t(), 
        by.x = "short", by.y = 0, sort = FALSE)
rownames(std_means_diff_kfre) = std_means_diff_kfre$long
std_means_diff_kfre = std_means_diff_kfre[,-c(1:3)]
```

We plot the mean difference between treatment and control for each variable, within each quartile. 

```{r}
data.frame(est = gather(data.frame(std_means_diff_kfre))$value, 
           Quartile = rep(as.factor(1:4), each = nrow(std_means_diff_kfre))) %>% 
  mutate(y = rep(1:nrow(std_means_diff_kfre), 4) + 
           rep(seq(-0.2, 0.2, length = 4), each = nrow(std_means_diff_kfre))) %>% 
  ggplot(aes(x = as.numeric(est), y = y, color = Quartile)) +
  geom_point() + 
  scale_color_manual(values = c("navy", "dodgerblue", "mediumpurple","firebrick")) + 
  scale_y_continuous(breaks = 1:nrow(std_means_diff_kfre), 
                     labels = rownames(std_means_diff_kfre), 
                     expand = c(0.02, 0.02)) + 
  xlab("Difference in standardized mean between treatment and control") + ylab("") + 
  ggtitle("Imbalance by KFRE quartile")
ggsave("figs_and_tabs/kfre_imbalance.png", width = 6, height = 5)

write.csv(std_means_diff_kfre %>% round(3), 
          file = "figs_and_tabs/std_means_diff_kfre.csv")
std_means_diff_kfre %>% round(3)
```

No covariates were imbalanced (defined as the mean difference between treatment and control being greater than 0.1 for at least one quartile), so we will not run an adjusted analysis. 

```{r}
# Which variables are imbalanced by more than 0.05 standard units?
is_imbalanced = apply(std_means_diff_kfre, 1, function(x){
  any(abs(x) > 0.1)
})

imbalanced_vars = dat_dict$short[which(dat_dict$long %in%
                                         names(is_imbalanced)[is_imbalanced])]
imbalanced_vars
```

## Treatment effects

We estimate the 7-year RMST differences for each subgroup defined by the KFRE quartiles. 

```{r}
# Horizon
horizon = 365*7

# RMST difference overall
overall_rmst = sapply(outcome_list, function(x){
  df_sub = na.omit(df[,c(x["time"], x["status"], "glyarm", "kfre_quarts")])
  rmst2(df_sub[,x["time"]], 
        df_sub[,x["status"]], 
        df_sub[,"glyarm"], 
        tau = horizon)$unadjusted.result[1,1]
})
# RMST difference by quartile
kfre_quart_rmst = sapply(outcome_list, function(x){
  df_sub = na.omit(df[,c(x["time"], x["status"], "glyarm", "kfre_quarts")])
  sapply(1:4, function(i){
    rmst2(df_sub[df_sub$kfre_quarts==i,x["time"]], 
          df_sub[df_sub$kfre_quarts==i,x["status"]], 
          df_sub[df_sub$kfre_quarts==i,"glyarm"], 
          tau = horizon)$unadjusted.result[1,1]
  })
})
```

We use 1000 bootstrap samples to obtain confidence intervals for the RMST differences. Tables of the RMST differences and normalized RMST differences (where the overall RMST difference is subtracted from each quartile's estime) with 95% bootstrap CIs are shown below. 

```{r}
# Number of bootstraps/permutations
B = 1000
```

```{r, echo = FALSE}
load("boot_kfre_rmst.rData")
```

```{r, eval = FALSE}
boot_kfre_rmst = foreach::foreach(
  b = 1:B, 
  .packages = c("survRM2")
  ) %dopar% {
    # Set seed
    set.seed(b)
    # Create bootstrap sample
    boot_idx = sample(nrow(df), replace= TRUE)
    df_boot = df[boot_idx,]
    
    # Calculate overall RMST difference
    overall_rmst = sapply(outcome_list, function(x){
      df_sub = na.omit(df_boot[,c(x["time"], x["status"], "glyarm", "kfre_quarts")])
      rmst2(df_sub[,x["time"]], 
            df_sub[,x["status"]], 
            df_sub[,"glyarm"], 
            tau = horizon)$unadjusted.result[1,1]
      })
    
    # Calculate RMST difference for each quartile
    kfre_quart_rmst = sapply(outcome_list, function(x){
      df_sub = na.omit(df_boot[,c(x["time"], x["status"], "glyarm", "kfre_quarts")])
      sapply(1:4, function(i){
        rmst2(df_sub[df_sub$kfre_quarts==i,x["time"]], 
              df_sub[df_sub$kfre_quarts==i,x["status"]], 
              df_sub[df_sub$kfre_quarts==i,"glyarm"], 
              tau = horizon)$unadjusted.result[1,1]
      })
    })
    return(list(overall_rmst = overall_rmst, 
                kfre_quart_rmst = kfre_quart_rmst))
  }

save(boot_kfre_rmst, file = "boot_kfre_rmst.rData")
```

```{r}
# Overall
kfre_overall_rmst_boot_ci = apply(
  sapply(boot_kfre_rmst, function(x){
    x$overall_rmst
  }), 1, quantile, c(0.025, 0.975))

# Not normalized
kfre_quart_rmst_boot_ci = lapply(1:4, function(i){
  dat = sapply(boot_kfre_rmst, function(x){
    x$kfre_quart_rmst[i,]
  })
  apply(dat, 1, quantile, c(0.025, 0.975))
})

# Make tables
kfre_quart_rmst_boot_tabs = lapply(names(outcome_list), function(outcome){
  out = rbind(
    data.frame(Quartile = "Overall", 
               "Est" = overall_rmst[outcome], 
               t(kfre_overall_rmst_boot_ci[,outcome])), 
    data.frame(Quartile = 1:4, 
               "Est" = kfre_quart_rmst[,outcome], 
               t(sapply(kfre_quart_rmst_boot_ci, function(x){x[,outcome]}))))
  rownames(out) = NULL
  return(out)
})
names(kfre_quart_rmst_boot_tabs) = names(outcome_list)

# Format table for printing
rmst_tab = data.frame(
  Outcome = rep(names(kfre_quart_rmst_boot_tabs), 
                each = nrow(kfre_quart_rmst_boot_tabs[[1]])), 
  do.call(rbind, kfre_quart_rmst_boot_tabs), 
  row.names = NULL
)
rmst_tab = merge(dat_dict[,c("short", "long")], rmst_tab, 
                 by.x = "short", by.y = "Outcome", all.y = TRUE, 
                 sort = FALSE)[,-1]
names(rmst_tab) = c("Outcome", "Quartile", "Est", "2.5%", "97.5%")
rmst_tab[,c("Est", "2.5%", "97.5%")] = 
  round(rmst_tab[,c("Est", "2.5%", "97.5%")], 2)
write.csv(rmst_tab, 
          file = "figs_and_tabs/rmst_tab.csv", row.names = FALSE)
rmst_tab

# Normalized (subtract overall RMST difference)
kfre_quart_rmst_norm_boot_ci = lapply(1:4, function(i){
  dat = sapply(boot_kfre_rmst, function(x){
    x$kfre_quart_rmst[i,] - x$overall_rmst
  })
  apply(dat, 1, quantile, c(0.025, 0.975))
})

# Make tables
kfre_quart_rmst_boot_norm_tabs = lapply(names(outcome_list), function(outcome){
  data.frame(Quartile = 1:4, 
               "Est" = kfre_quart_rmst[,outcome] - overall_rmst[outcome], 
               t(sapply(kfre_quart_rmst_norm_boot_ci, function(x){x[,outcome]})))
})
names(kfre_quart_rmst_boot_norm_tabs) = names(outcome_list)

# Format table for printing
rmst_norm_tab = data.frame(
  Outcome = rep(names(kfre_quart_rmst_boot_norm_tabs), 
                each = nrow(kfre_quart_rmst_boot_norm_tabs[[1]])), 
  do.call(rbind, kfre_quart_rmst_boot_norm_tabs), 
  row.names = NULL
)
rmst_norm_tab = merge(dat_dict[,c("short", "long")], rmst_norm_tab, 
                      by.x = "short", by.y = "Outcome", all.y = TRUE, 
                      sort = FALSE)[,-1]
names(rmst_norm_tab) = c("Outcome", "Quartile", "Est", "2.5%", "97.5%")
rmst_norm_tab[,c("Est", "2.5%", "97.5%")] = 
  round(rmst_norm_tab[,c("Est", "2.5%", "97.5%")], 2)
write.csv(rmst_norm_tab, 
          file = "figs_and_tabs/rmst_norm_tab.csv", row.names = FALSE)
rmst_norm_tab
```

These are plots of the RMST differences by outcome, with a horizontal reference line drawn at the overall/ATE point estimate. Shading denotes the ATE CI. 

```{r}
for (outcome in names(kfre_quart_rmst_boot_tabs)) {
  ate_tab = kfre_quart_rmst_boot_tabs[[outcome]][1,]
  p1 = kfre_quart_rmst_boot_tabs[[outcome]][-1,] %>% 
    mutate(x = 1:4) %>% 
    ggplot(aes(x = x, y = as.numeric(Est))) +
    geom_pointrange(aes(ymin = X2.5., ymax = X97.5.), size = 0.25) + 
    geom_hline(yintercept = ate_tab[,"Est"], color = "grey") + 
    annotate("rect", xmin = -Inf, xmax = Inf, 
             ymin = ate_tab[,"X2.5."], ymax = ate_tab[,"X97.5."], 
             alpha = 0.2) + 
    scale_x_continuous(breaks = 1:4, labels = 1:4) + 
    theme(legend.position = 'bottom', legend.box = 'vertical') + 
    xlab("Quartile") + ylab("RMST difference") +
    ggtitle(dat_dict$long[which(dat_dict$short == outcome)])
  print(p1)
  ggsave(paste0("figs_and_tabs/rmst_", outcome, ".png"), 
         width = 6, height = 4)
}
```

Normalized RMST differences. 

```{r}
for (outcome in names(kfre_quart_rmst_boot_norm_tabs)) {
  p1 = kfre_quart_rmst_boot_norm_tabs[[outcome]] %>% 
    mutate(x = 1:4) %>% 
    ggplot(aes(x = x, y = as.numeric(Est))) +
    geom_pointrange(aes(ymin = X2.5., ymax = X97.5.), size = 0.25) + 
    scale_x_continuous(breaks = 1:4, labels = 1:4) + 
    theme(legend.position = 'bottom', legend.box = 'vertical') + 
    xlab("Quartile") + ylab("Normalized RMST difference") + 
    geom_hline(yintercept = 0, color = "grey") + 
    ggtitle(dat_dict$long[which(dat_dict$short == outcome)])
  print(p1)
  ggsave(paste0("figs_and_tabs/rmst_norm_", outcome, ".png"), 
         width = 6, height = 4)
}
```

## Cox PH models and cumulative incidence curves

For each outcome, we fit a Cox PH model to treatment for the entire dataset and each group defined by the KFRE quartiles. Estimates of the treatment hazard ratios are shown below.  

```{r}
# Fit Cox PH model for each outcome to glyarm
coxph_fits = lapply(names(outcome_list), function(outcome){
  # Extract data of interest
  x = outcome_list[[outcome]]
  df_sub = na.omit(df[,c(x["time"], x["status"], "glyarm")])
  
  # Formula for survfit object
  form = formula(paste0("Surv(", x["time"], ", " , 
                        x["status"], ") ~ glyarm"))
  # Fit survfit object
  fit = coxph(form, data = df_sub)
  # Manually insert formula
  fit$call$formula = form
  
  return(fit)
})
names(coxph_fits) = names(outcome_list)

# Fit Cox PH models within quartile
coxph_fits_by_quart = lapply(names(outcome_list), function(outcome){
  # Extract data of interest
  x = outcome_list[[outcome]]
  df_sub = na.omit(df[,c(x["time"], x["status"], "glyarm", "kfre_quarts")])
  
  # Formula for survfit object
  form = formula(paste0("Surv(", x["time"], ", " , 
                        x["status"], ") ~ glyarm"))
  
  all_fits = lapply(1:4, function(i){
    # Subset data to quartile
    df_sub = df_sub[df_sub$kfre_quarts==i, ]
    
    # Fit survfit object
    fit = coxph(form, data = df_sub)
    # Manually insert formula
    fit$call$formula = form
    return(fit)
  })
  
  return(all_fits)
})
names(coxph_fits_by_quart) = names(outcome_list)

# Make tables
coxph_coeff_tabs = lapply(names(outcome_list), function(outcome){
  out = rbind(
    data.frame(Quartile = "Overall", 
               t(exp(c(coef(coxph_fits[[outcome]]), confint(coxph_fits[[outcome]]))))
               ), 
    data.frame(Quartile = 1:4, 
               do.call(rbind, 
                       lapply(coxph_fits_by_quart[[outcome]], function(x){
                         exp(c(coef(x), confint(x)))
                         }))
               ))
  rownames(out) = NULL
  colnames(out) = c("Quartile", "Est", "X2.5.", "X97.5.")
  return(out)
})
names(coxph_coeff_tabs) = names(outcome_list)

# Format table for printing
coeff_tab = data.frame(
  Outcome = rep(names(coxph_coeff_tabs), 
                each = nrow(coxph_coeff_tabs[[1]])), 
  do.call(rbind, coxph_coeff_tabs), 
  row.names = NULL
)
coeff_tab = merge(dat_dict[,c("short", "long")], coeff_tab, 
                  by.x = "short", by.y = "Outcome", all.y = TRUE, 
                  sort = FALSE)[,-1]
names(coeff_tab) = c("Outcome", "Quartile", "Est", "2.5%", "97.5%")
coeff_tab[,c("Est", "2.5%", "97.5%")] = 
  round(coeff_tab[,c("Est", "2.5%", "97.5%")], 2)
write.csv(coeff_tab, 
          file = "figs_and_tabs/coeff_tab.csv", row.names = FALSE)
coeff_tab
```

We plot cumulative incidence curves and risk tables for each outcome. 

```{r, fig.width = 6, fig.height = 6}
# Helper function for formatting labels of the form est (lo, hi)
est_with_ci_text = function(x, est = "Est", lo = "X2.5.", hi = "X97.5.", 
                            digits = 2) {
  x = round(x[c(est, lo, hi)], 2)
  paste0(x[est], " (", x[lo], ", ", x[hi], ")")
}

invisible(lapply(names(outcome_list), function(outcome){
  # Extract data of interest
  x = outcome_list[[outcome]]
  df_sub = na.omit(df[,c(x["time"], x["status"], "glyarm", "kfre_quarts")])
  
  # Formula for survfit object
  form = formula(paste0("Surv(", x["time"], ", " , 
                        x["status"], ") ~ glyarm"))
  # Fit survfit object
  fit = survfit(form, data = df_sub)
  # Manually insert formula
  fit$call$formula = form
  
  # Plot cumulative incidence curve with risk table
  p1 = ggsurvplot(fit, data = df_sub, censor = FALSE, 
                  title = dat_dict$long[which(dat_dict$short == outcome)], 
                  conf.int = TRUE, risk.table = TRUE, fun = "event", 
                  legend.labs = c("Control", "Treatment"))
  # Create annotation for hazard ratio and 7-year RMST
  p1$plot = p1$plot + 
    annotate("label", x = 0, y = Inf, vjust = 1, hjust = 0, 
             size = 4, fontface = 2, 
             label = paste0("HR = ", 
                            est_with_ci_text(coxph_coeff_tabs[[outcome]][1,-1]), 
                            "\n7-year RMST difference\n   = ", 
                            est_with_ci_text(kfre_quart_rmst_boot_tabs[[outcome]][1,-1])))
  
  png(paste0("figs_and_tabs/cum_inc_", outcome, ".png"), 
      res = 100, width = 600, height = 600)
  print(p1)
  dev.off()
  print(p1)
}))
```

We plot cumulative incidence curves for each outcome, faceted by quartile. 

```{r, fig.width = 10, fig.height = 10}
invisible(lapply(names(outcome_list), function(outcome){
  # Extract data of interest
  x = outcome_list[[outcome]]
  df_sub = na.omit(df[,c(x["time"], x["status"], "glyarm", "kfre_quarts")])
  
  # Formula for survfit object
  form = formula(paste0("Surv(", x["time"], ", " , 
                        x["status"], ") ~ glyarm"))
  
  all_plots = lapply(1:4, function(i){
    # Subset data to quartile
    df_sub = df_sub[df_sub$kfre_quarts==i, ]
    
    # Fit survfit object
    fit = survfit(form, data  =df_sub)
    # Manually insert formula
    fit$call$formula = form
    
    # Plot cumulative incidence curve with risk table
    if (outcome == "Neph2") {
      outcome_title = "Development of \nmacro-albuminuria"
    } else if (outcome == "Neph3") {
      outcome_title = "Renal failure or ESRD \n(dialysis) or SCr>3.3"
    } else {
      outcome_title = dat_dict$long[which(dat_dict$short == outcome)]
    }
    p1 = ggsurvplot(fit, data = df_sub,  censor = FALSE, 
                    title = paste0(outcome_title, ": \nQuartile ", i), 
                    conf.int = TRUE, risk.table = TRUE, fun = "event", 
                    legend.labs = c("Control", "Treatment"))
    
    # Create annotation for hazard ratio and 7-year RMST
    p1$plot = p1$plot + 
      annotate("label", x = 0, y = Inf, vjust = 1, hjust = 0, 
               size = 4, fontface = 2, 
               label = paste0("HR = ", 
                            est_with_ci_text(coxph_coeff_tabs[[outcome]][1+i,-1]), 
                            "\n7-year RMST difference\n   = ", 
                            est_with_ci_text(kfre_quart_rmst_boot_tabs[[outcome]][1+i,-1])))
    return(p1)
  })
  
  # Collect all quartile plots for outcome
  png(paste0("figs_and_tabs/cum_inc_quart_", outcome, ".png"), 
       res = 100, width = 1200, height = 1200)
  arrange_ggsurvplots(all_plots, print = TRUE,
                      nrow = 2, ncol = 2)
  dev.off()
  arrange_ggsurvplots(all_plots, print = TRUE,
                      nrow = 2, ncol = 2)
}))
```

### Deciles

We repeat the HTE analysis using KFRE deciles to define the subgroups. The tables summarize the point estimates and 95% bootstrap CIs for 7-year RMST differences and normalized RMST differences by KFRE decile. 

```{r}
# kfre decile thresholds
kfre_dec_thresh = quantile(df$kfre5, seq(0.1, 0.9, by = 0.1))
# Create groups based on thresholds
df$kfre_dec = as.numeric(cut(df$kfre5, 
                             breaks = c(-Inf, as.numeric(kfre_dec_thresh), Inf),
                             labels = c(1:(length(kfre_dec_thresh)+1))))

# RMST difference by decile
kfre_dec_rmst = sapply(outcome_list, function(x){
  df_sub = na.omit(df[,c(x["time"], x["status"], "glyarm", 'kfre_dec')])
  sapply(1:10, function(i){
    rmst2(df_sub[df_sub$kfre_dec==i,x["time"]], 
          df_sub[df_sub$kfre_dec==i,x["status"]], 
          df_sub[df_sub$kfre_dec==i,"glyarm"], 
          tau = horizon)$unadjusted.result[1,1]
  })
})
```

```{r, echo = FALSE}
load("boot_kfre_dec_rmst.rData")
```

```{r, eval = FALSE}
boot_kfre_dec_rmst = foreach::foreach(
  b = 1:B, 
  .packages = c("survRM2")
  ) %dopar% {
    # Set seed
    set.seed(b)
    # Create bootstrap sample
    boot_idx = sample(nrow(df), replace= TRUE)
    df_boot = df[boot_idx,]
    
    # Calculate overall RMST difference
    overall_rmst = sapply(outcome_list, function(x){
      df_sub = na.omit(df_boot[,c(x["time"], x["status"], "glyarm", "kfre_dec")])
      rmst2(df_sub[,x["time"]], 
            df_sub[,x["status"]], 
            df_sub[,"glyarm"], 
            tau = horizon)$unadjusted.result[1,1]
      })
    
    # Calculate RMST difference for each decile
    kfre_dec_rmst = sapply(outcome_list, function(x){
      df_sub = na.omit(df_boot[,c(x["time"], x["status"], "glyarm", "kfre_dec")])
      sapply(1:10, function(i){
        rmst2(df_sub[df_sub$kfre_dec==i,x["time"]], 
              df_sub[df_sub$kfre_dec==i,x["status"]], 
              df_sub[df_sub$kfre_dec==i,"glyarm"], 
              tau = horizon)$unadjusted.result[1,1]
      })
    })
    return(list(overall_rmst = overall_rmst, 
                kfre_dec_rmst = kfre_dec_rmst))
  }

save(boot_kfre_dec_rmst, file = "boot_kfre_dec_rmst.rData")
```

```{r}
# Not normalized
kfre_dec_rmst_boot_ci = lapply(1:10, function(i){
  dat = sapply(boot_kfre_dec_rmst, function(x){
    x$kfre_dec_rmst[i,]
  })
  apply(dat, 1, quantile, c(0.025, 0.975))
})

# Make table
kfre_dec_rmst_boot_tabs = lapply(names(outcome_list), function(outcome){
  out = rbind(
    data.frame(Decile = "Overall", 
               "Est" = overall_rmst[outcome], 
               t(kfre_overall_rmst_boot_ci[,outcome])), 
    data.frame(Decile = 1:10, 
               "Est" = kfre_dec_rmst[,outcome], 
               t(sapply(kfre_dec_rmst_boot_ci, function(x){x[,outcome]}))))
  rownames(out) = NULL
  return(out)
})
names(kfre_dec_rmst_boot_tabs) = names(outcome_list)

# Format table for printing
rmst_dec_tab = data.frame(
  Outcome = rep(names(kfre_dec_rmst_boot_tabs), 
                each = nrow(kfre_dec_rmst_boot_tabs[[1]])), 
  do.call(rbind, kfre_dec_rmst_boot_tabs), 
  row.names = NULL
)
rmst_dec_tab = merge(dat_dict[,c("short", "long")], rmst_dec_tab, 
                     by.x = "short", by.y = "Outcome", all.y = TRUE, 
                     sort = FALSE)[,-1]
names(rmst_dec_tab) = c("Outcome", "Decile", "Est", "2.5%", "97.5%")
rmst_dec_tab[,c("Est", "2.5%", "97.5%")] = 
  round(rmst_dec_tab[,c("Est", "2.5%", "97.5%")], 2)
write.csv(rmst_dec_tab, 
          file = "figs_and_tabs/rmst_dec_tab.csv", row.names = FALSE)
rmst_dec_tab


# Normalized (subtract overall RMST difference)
kfre_dec_rmst_norm_boot_ci = lapply(1:10, function(i){
  dat = sapply(boot_kfre_dec_rmst, function(x){
    x$kfre_dec_rmst[i,] - x$overall_rmst
  })
  apply(dat, 1, quantile, c(0.025, 0.975))
})

# Make a table
kfre_dec_rmst_boot_norm_tabs = lapply(names(outcome_list), function(outcome){
  out = rbind(
    data.frame(Decile = 1:10, 
               "Est" = kfre_dec_rmst[,outcome] - overall_rmst[outcome], 
               t(sapply(kfre_dec_rmst_norm_boot_ci, function(x){x[,outcome]}))))
  rownames(out) = NULL
  return(out)
})
names(kfre_dec_rmst_boot_norm_tabs) = names(outcome_list)

# Format table for printing
rmst_norm_dec_tab = data.frame(
  Outcome = rep(names(kfre_dec_rmst_boot_norm_tabs), 
                each = nrow(kfre_dec_rmst_boot_norm_tabs[[1]])), 
  do.call(rbind, kfre_dec_rmst_boot_norm_tabs), 
  row.names = NULL
)
rmst_norm_dec_tab = merge(dat_dict[,c("short", "long")], rmst_norm_dec_tab, 
                          by.x = "short", by.y = "Outcome", all.y = TRUE, 
                          sort = FALSE)[,-1]
names(rmst_norm_dec_tab) = c("Outcome", "Decile", "Est", "2.5%", "97.5%")
rmst_norm_dec_tab[,c("Est", "2.5%", "97.5%")] = 
  round(rmst_norm_dec_tab[,c("Est", "2.5%", "97.5%")], 2)
write.csv(rmst_norm_dec_tab, 
          file = "figs_and_tabs/rmst_norm_dec_tab.csv", row.names = FALSE)
rmst_norm_dec_tab
```

RMST differences.

```{r}
for (outcome in names(kfre_dec_rmst_boot_tabs)) {
  ate_tab = kfre_dec_rmst_boot_tabs[[outcome]][1,]
  p1 = kfre_dec_rmst_boot_tabs[[outcome]][-1,] %>% 
    mutate(x = 1:10) %>% 
    ggplot(aes(x = x, y = as.numeric(Est))) +
    geom_pointrange(aes(ymin = X2.5., ymax = X97.5.), size = 0.25) + 
    geom_hline(yintercept = ate_tab[,"Est"], color = "grey") + 
    annotate("rect", xmin = -Inf, xmax = Inf, 
             ymin = ate_tab[,"X2.5."], ymax = ate_tab[,"X97.5."], 
             alpha = 0.2) + 
    scale_x_continuous(breaks = 1:10, labels = 1:10) + 
    theme(legend.position = 'bottom', legend.box = 'vertical') + 
    xlab("Decile") + ylab("RMST difference") +
    ggtitle(dat_dict$long[which(dat_dict$short == outcome)])
  print(p1)
  ggsave(paste0("figs_and_tabs/rmst_dec_", outcome, ".png"), 
         width = 6, height = 4)
}
```

Normalized RMST differences. 

```{r}
for (outcome in names(kfre_dec_rmst_boot_norm_tabs)) {
  p1 = kfre_dec_rmst_boot_norm_tabs[[outcome]] %>% 
    mutate(x = 1:10) %>% 
    ggplot(aes(x = x, y = as.numeric(Est))) +
    geom_pointrange(aes(ymin = X2.5., ymax = X97.5.), size = 0.25) + 
    scale_x_continuous(breaks = 1:10, labels = 1:10) + 
    theme(legend.position = 'bottom', legend.box = 'vertical') + 
    xlab("Decile") + ylab("Normalized RMST difference") + 
    geom_hline(yintercept = 0, color = "grey") + 
    ggtitle(dat_dict$long[which(dat_dict$short == outcome)])
  print(p1)
  ggsave(paste0("figs_and_tabs/rmst_norm_dec_", outcome, ".png"), 
         width = 6, height = 4)
}
```

## Jiang's Diabetic Kidney Disease (DKD) score

We use the score from Jiang (2020) "Establishment and Validation of a Risk Prediction Model for Early Diabetic Kidney Disease Based on a Systematic Review and Meta-Analysis of 20 Cohorts" to define quartile subgroups. There are 1327 missing values, mostly due to missing smoking status. 

```{r}
# Diabetic retinopathy variable
baselinehistoryandphyisical = read.csv("/Users/jliang/Library/CloudStorage/Box-Box/RELATE\ CKD/Study\ Datasets/ACCORD/ACCORD_2017b_2\ 2/Main_Study/4-Data_Sets-CRFs/4a-CRF_Data_Sets/csv/f07_baselinehistoryphysicalexam.csv")
baselinehistoryandphyisical = baselinehistoryandphyisical %>% 
  mutate(retinopathy = case_when(retpathy==1 | lrtpathy==1 | rrtpathy==1 ~ 1, 
                                 TRUE ~ 0))

# Merge in diabetic retinopathy and years of diabetes
df_dkd =  merge(df, 
            baselinehistoryandphyisical %>% 
              select(MaskID, retinopathy), 
            by.x = "maskid", by.y = "MaskID", all.x = TRUE)

# Calculate dkd score from Jiang 2020
df_dkd = df_dkd %>% 
  mutate(dkd = case_when(baseline_age <= 49 ~ 0, 
                         baseline_age <= 59 ~ 3, 
                         baseline_age > 59 ~ 6) + 
           case_when(bmi < 25 ~ 0, 
                     bmi < 30 ~ 1.5, 
                     bmi >= 30  ~ 3) + 
           case_when(smokelif == FALSE ~ 0, 
                     smokelif == TRUE ~ 4) + 
           case_when(retinopathy == FALSE ~ 0, 
                     retinopathy == TRUE ~ 3) + 
           case_when(hba1c < 7 ~ 0, 
                     hba1c < 8 ~ 1.5, 
                     hba1c < 9 ~ 3, 
                     hba1c >= 9 ~ 4.5) + 
           case_when(sbp < 130 ~ 0, 
                     sbp < 140 ~ 2, 
                     sbp < 150 ~ 4, 
                     sbp >= 150 ~ 6) + 
           case_when(hdl < 1.3*18 ~ 0, 
                     hdl >= 1.3*18 ~ 2.5) + 
           case_when(trig < 1.7*18 ~ 0, 
                     trig >= 1.7*18 ~ 4)+ 
           case_when(uacr < 10 ~ 0, 
                     uacr < 20 ~ 2, 
                     uacr >= 20 ~ 4))

df_dkd %>% summarise_all(~ sum(is.na(.)))

# Drop NAs
df_dkd = df_dkd %>% 
  drop_na(dkd)

# DKD quartile thresholds
dkd_quart_thresh = quantile(df_dkd$dkd, seq(0.25, 0.75, by = 0.25))
# Create groups based on thresholds
df_dkd$dkd_quarts = as.numeric(cut(df_dkd$dkd, 
                               breaks = c(-Inf, as.numeric(dkd_quart_thresh), Inf),
                               labels = c(1:(length(dkd_quart_thresh)+1))))
```

This score seems to be somewhat correlated with 5-year KFRE. 

```{r}
# Spearman's correlation
cor(df_dkd$kfre5, df_dkd$dkd, use = "complete.obs", method = "spearman")

# Scatterplot
df_dkd %>% 
  ggplot(aes(x = kfre5, y = dkd)) + 
  geom_point() + 
  scale_x_log10() + 
  xlab("5-year predicted risk by KFRE (log)") + ylab("Jiang's DKD score")
ggsave("figs_and_tabs/dkd_vs_kfre.png", width = 6, height = 5)
```

Number of observations overall and in each arm, restricting to those with non-missing covariates needed to calculate the DKD score.  

```{r}
c(table(df_dkd$glyarm), Overall = nrow(df_dkd))
```

Number of non-missing observations for each outcome. 

```{r}
t(sapply(outcome_list, function(x) {
  my_df = na.omit(df_dkd[,c(x["status"], x["time"], "glyarm")])
  c(table(my_df$glyarm), Overall = nrow(my_df))
}))
```

We estimate the 7-year RMST differences for each subgroup defined by the DKD quartiles. 

```{r}
# Horizon
horizon = 365*7

# Overall
dkd_overall_rmst = sapply(outcome_list, function(x){
  df_sub = na.omit(df_dkd[,c(x["time"], x["status"], "glyarm", "dkd_quarts")])
  rmst2(df_sub[,x["time"]], 
        df_sub[,x["status"]], 
        df_sub[,"glyarm"], 
        tau = horizon)$unadjusted.result[1,1]
})
# By quartile
dkd_quart_rmst = sapply(outcome_list, function(x){
  df_sub = na.omit(df_dkd[,c(x["time"], x["status"], "glyarm", "dkd_quarts")])
  sapply(1:4, function(i){
    rmst2(df_sub[df_sub$dkd_quarts==i,x["time"]], 
          df_sub[df_sub$dkd_quarts==i,x["status"]], 
          df_sub[df_sub$dkd_quarts==i,"glyarm"], 
          tau = horizon)$unadjusted.result[1,1]
  })
})
```

We use 1000 bootstrap samples to obtain confidence intervals for the RMST differences. Tables of the RMST differences and normalized RMST differences (where the overall RMST difference is subtracted from each quartile's estime) with 95% bootstrap CIs are shown below. 

```{r}
# Number of bootstraps/permutations
B = 1000
```

```{r, echo = FALSE}
load("boot_dkd_rmst.rData")
```

```{r, eval = FALSE}
boot_dkd_rmst = foreach::foreach(
  b = 1:B, 
  .packages = c("survRM2")
  ) %dopar% {
    # Set seed
    set.seed(b)
    # Create bootstrap sample
    boot_idx = sample(nrow(df), replace= TRUE)
    df_boot = df_dkd[boot_idx,]
    
    # Calculate overall RMST difference
    overall_rmst = sapply(outcome_list, function(x){
      df_sub = na.omit(df_boot[,c(x["time"], x["status"], "glyarm", "dkd_quarts")])
      rmst2(df_sub[,x["time"]], 
            df_sub[,x["status"]], 
            df_sub[,"glyarm"], 
            tau = horizon)$unadjusted.result[1,1]
      })
    
    # Calculate RMST difference for each quartile
    dkd_quart_rmst = sapply(outcome_list, function(x){
      df_sub = na.omit(df_boot[,c(x["time"], x["status"], "glyarm", "dkd_quarts")])
      sapply(1:4, function(i){
        rmst2(df_sub[df_sub$dkd_quarts==i,x["time"]], 
              df_sub[df_sub$dkd_quarts==i,x["status"]], 
              df_sub[df_sub$dkd_quarts==i,"glyarm"], 
              tau = horizon)$unadjusted.result[1,1]
      })
    })
    return(list(overall_rmst = overall_rmst, 
                dkd_quart_rmst = dkd_quart_rmst))
  }

save(boot_dkd_rmst, file = "boot_dkd_rmst.rData")
```

```{r}
# Overall
dkd_overall_rmst_boot_ci = apply(
  sapply(boot_dkd_rmst, function(x){
    x$overall_rmst
  }), 1, quantile, c(0.025, 0.975))

# Not normalized
dkd_quart_rmst_boot_ci = lapply(1:4, function(i){
  dat = sapply(boot_dkd_rmst, function(x){
    x$dkd_quart_rmst[i,]
  })
  apply(dat, 1, quantile, c(0.025, 0.975))
})

# Make tables
dkd_quart_rmst_boot_tabs = lapply(names(outcome_list), function(outcome){
  out = rbind(
    data.frame(Quartile = "Overall", 
               "Est" = dkd_overall_rmst[outcome], 
               t(dkd_overall_rmst_boot_ci[,outcome])), 
    data.frame(Quartile = 1:4, 
               "Est" = dkd_quart_rmst[,outcome], 
               t(sapply(dkd_quart_rmst_boot_ci, function(x){x[,outcome]}))))
  rownames(out) = NULL
  return(out)
})
names(dkd_quart_rmst_boot_tabs) = names(outcome_list)

# Format table for printing
dkd_rmst_tab = data.frame(
  Outcome = rep(names(dkd_quart_rmst_boot_tabs), 
                each = nrow(dkd_quart_rmst_boot_tabs[[1]])), 
  do.call(rbind, dkd_quart_rmst_boot_tabs), 
  row.names = NULL
)
dkd_rmst_tab = merge(dat_dict[,c("short", "long")], dkd_rmst_tab, 
                     by.x = "short", by.y = "Outcome", all.y = TRUE, 
                     sort = FALSE)[,-1]
names(dkd_rmst_tab) = c("Outcome", "Quartile", "Est", "2.5%", "97.5%")
dkd_rmst_tab[,c("Est", "2.5%", "97.5%")] = 
  round(dkd_rmst_tab[,c("Est", "2.5%", "97.5%")], 2)
write.csv(dkd_rmst_tab, 
          file = "figs_and_tabs/dkd_rmst_tab.csv", row.names = FALSE)
dkd_rmst_tab

# Normalized (subtract overall RMST difference)
dkd_quart_rmst_norm_boot_ci = lapply(1:4, function(i){
  dat = sapply(boot_dkd_rmst, function(x){
    x$dkd_quart_rmst[i,] - x$overall_rmst
  })
  apply(dat, 1, quantile, c(0.025, 0.975))
})

# Make tables
dkd_quart_rmst_boot_norm_tabs = lapply(names(outcome_list), function(outcome){
  data.frame(Quartile = 1:4, 
             "Est" = dkd_quart_rmst[,outcome] - dkd_overall_rmst[outcome], 
             t(sapply(dkd_quart_rmst_norm_boot_ci, function(x){x[,outcome]})))
})
names(dkd_quart_rmst_boot_norm_tabs) = names(outcome_list)

# Format table for printing
dkd_rmst_norm_tab = data.frame(
  Outcome = rep(names(dkd_quart_rmst_boot_norm_tabs), 
                each = nrow(dkd_quart_rmst_boot_norm_tabs[[1]])), 
  do.call(rbind, dkd_quart_rmst_boot_norm_tabs), 
  row.names = NULL
)
dkd_rmst_norm_tab = merge(dat_dict[,c("short", "long")], dkd_rmst_norm_tab, 
                          by.x = "short", by.y = "Outcome", all.y = TRUE, 
                          sort = FALSE)[,-1]
names(dkd_rmst_norm_tab) = c("Outcome", "Quartile", "Est", "2.5%", "97.5%")
dkd_rmst_norm_tab[,c("Est", "2.5%", "97.5%")] = 
  round(dkd_rmst_norm_tab[,c("Est", "2.5%", "97.5%")], 2)
write.csv(dkd_rmst_norm_tab, 
          file = "figs_and_tabs/dkd_rmst_norm_tab.csv", row.names = FALSE)
dkd_rmst_norm_tab
```

These are plots of the RMST differences by outcome, with a horizontal reference line drawn at the overall/ATE point estimate. Shading denotes the ATE CI. 

```{r}
for (outcome in names(dkd_quart_rmst_boot_tabs)) {
  ate_tab = dkd_quart_rmst_boot_tabs[[outcome]][1,]
  p1 = dkd_quart_rmst_boot_tabs[[outcome]][-1,] %>% 
    mutate(x = 1:4) %>% 
    ggplot(aes(x = x, y = as.numeric(Est))) +
    geom_pointrange(aes(ymin = X2.5., ymax = X97.5.), size = 0.25) + 
    geom_hline(yintercept = ate_tab[,"Est"], color = "grey") + 
    annotate("rect", xmin = -Inf, xmax = Inf, 
             ymin = ate_tab[,"X2.5."], ymax = ate_tab[,"X97.5."], 
             alpha = 0.2) + 
    scale_x_continuous(breaks = 1:4, labels = 1:4) + 
    theme(legend.position = 'bottom', legend.box = 'vertical') + 
    xlab("Quartile") + ylab("RMST difference") +
    ggtitle(dat_dict$long[which(dat_dict$short == outcome)])
  print(p1)
  ggsave(paste0("figs_and_tabs/dkd_rmst_", outcome, ".png"), 
         width = 6, height = 4)
}
```

Normalized RMST differences. 

```{r}
for (outcome in names(dkd_quart_rmst_boot_norm_tabs)) {
  p1 = dkd_quart_rmst_boot_norm_tabs[[outcome]] %>% 
    mutate(x = 1:4) %>% 
    ggplot(aes(x = x, y = as.numeric(Est))) +
    geom_pointrange(aes(ymin = X2.5., ymax = X97.5.), size = 0.25) + 
    scale_x_continuous(breaks = 1:4, labels = 1:4) + 
    theme(legend.position = 'bottom', legend.box = 'vertical') + 
    xlab("Quartile") + ylab("Normalized RMST difference") + 
    geom_hline(yintercept = 0, color = "grey") + 
    ggtitle(dat_dict$long[which(dat_dict$short == outcome)])
  print(p1)
  ggsave(paste0("figs_and_tabs/dkd_rmst_norm_", outcome, ".png"), 
         width = 6, height = 4)
}
```
